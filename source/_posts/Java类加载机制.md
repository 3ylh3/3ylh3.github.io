---
title: Java类加载机制
date: 2020-03-10 20:57:46
categories: Java
tags:
 - 类加载
---
Java类加载主要有以下五个阶段：加载、验证、准备、解析和初始化，其中验证、准备和解析又被称为连接（Linking）。
#### 加载
加载的过程主要做了以下的事情：将类class文件中的二进制数据读入到内存中，存放在方法区中，然后在堆上创建一个该类的java.lang.Class对象,作为方法区中这些数据的访问入口，用来封装方法区中存放的类的数据结构。JVM规范允许类加载器预先加载某个类，并不需要等到它被首次主动使用时才加载。
<!-- more -->
#### 验证
验证是为了确保被加载的类的正确性，验证的内容包括以下几点：
- 类文件的结构检查：确保类文件遵从Java类文件的固定格式
- 语义检查：确保符合Java语法规定
- 字节码验证：确保字节码流可以被Java虚拟机安全的执行。
- 二进制兼容的验证：确保相互引用的类之间协调一致。
#### 准备
在准备阶段，Java虚拟机会为类的静态变量分配内存并设置初始默认值，这些内存都在方法区分配，以下例子中，准备阶段时会给int型变量a赋初始值0而不是1：
````java
public class test {
    private static int a = 1;
    private static int b;
}
````
需要注意的是准备阶段中只会为类的静态变量分配内存，类的非静态示例变量不会分配。
#### 解析
在解析阶段，Java虚拟机会把类二进制数据中的符号引用替换为直接饮用。首先介绍一下符号引用和直接引用：
- 符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量。
- 直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。
看以下例子：
````java
public class Test {
    private Car car;
    public void test {
        car.run();
    }
}
````
这个例子中,Test类的二进制数据中包含了一个对Car类的run()方法的符号引用，即car.run()。在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，指向Car类的run()方法在方法区中的内存位置，这个指针就是直接引用。
#### 初始化
在初始化阶段，Java虚拟机会执行类的初始化语句，给类的静态变量赋正确的初始值，静态变量初始化有两种方式：1.在声明处进行初始化。2.在静态代码块中初始化。如果一个静态变量没有初始化语句，那么它将保持默认初始值，看下面这个例子：
````java
public class test {
    private static int a = 1;
    private static int b;
    private static int c;
    static {
        b = 2;
    }
}
````
准备阶段时会执行变量a和b的初始化语句，将a赋值成1，b赋值成2，变量c没有初始化语句，将保持0。
静态变量声明语句和静态代码块都会被看作初始化语句，Java虚拟机会按照它们在类文件中的先后顺序依次执行。
类初始化步骤：
- 如果该类还没有加载和连接，则先进行加载和连接。
- 如果该类存在直接父类，并且这个父类还没有初始化，则先初始化这个父类。
- 如果该类中存在初始化语句，则依次执行。

类初始化时机：
类只有在首次被主动使用时才会初始化，主动使用包括以下六种情况：
- 创建类的实例，即new的方式。
- 访问某个类的静态变量，或者为该静态变量赋值。
- 调用类的静态方法。
- 反射调用（如Class.forName("com.xiaobai.test)）。
- 初始化一个类的子类。
- 直接使用 java.exe命令来运行某个主类

需要注意访问同时被static和final修饰的变量时不会触发类初始化；访问父类的静态变量时不会触发子类的初始化。

参考链接：
https://blog.csdn.net/L_Mr_l/article/details/81909995

https://blog.csdn.net/u014042066/article/details/77394480