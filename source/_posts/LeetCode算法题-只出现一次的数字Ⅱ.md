---
title: LeetCode算法题--只出现一次的数字Ⅱ
date: 2019-05-10 09:59:36
categories: 数据结构和算法
tags:
 - 数组
 - LeetCode
---
#### 题目描述：
137.给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。  

说明：  

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？  

示例 1:  

输入: [2,2,3,2]  
输出: 3  
示例 2:  

输入: [0,1,0,1,0,1,99]  
输出: 99  
<!-- more -->
#### 解题思路：  
如果数组中只有一个数，那么结果就是该数，否则对数组进行排序，排序后判断如果数组第一个数不等于第二个数，那么结果就是第一个数，否则判断数组最后一个数如果不等于前一个数，那么结果就是最后一个数，如果都不满足则证明结果是中间的数，从第二个数开始到倒数第二个数结束对数组进行遍历，如果当前位置的数既不等于前一个数又不等于后一个数，那么结果就是该数。  
#### Java实现：
```java
public int singleNumber(int[] nums) {
    //记录结果
    int res = 0;
    //如果数组只有一个数，那么结果为该数
    if(nums.length == 1){
        res = nums[0];
    }
    else {
        //对数组进行排序
        Arrays.sort(nums);
        //如果排序后第一个数不等于第二个数，那么结果为第一个数
        if (nums[0] != nums[1]) {
            res = nums[0];
        } else if (nums[nums.length - 1] != nums[nums.length - 2]) {
            //如果最后一个数不等于前一个数，那么结果为最后一个数
            res = nums[nums.length - 1];
        } else {
            //遍历数组（从数组第二位开始到倒数第二位结束），如果该数既不等于前一个数又不等于后一个数，那么结果为该数
            for (int i = 1; i < nums.length - 1; i++) {
                if (nums[i] != nums[i - 1] && nums[i] != nums[i + 1]) {
                    res = nums[i];
                    break;
                }
            }
        }
    }
    return res;
}
```