---
title: Java中的锁
date: 2020-03-24 21:34:58
categories: Java
tags:
 - 锁
 - 多线程
---
在讲Java中的锁之前，先介绍一下Java的线程状态,下图是Java线程状态图：
<!-- more -->
![线程状态图](https://xiaobai-picture.oss-cn-beijing.aliyuncs.com/Java%E4%B8%AD%E7%9A%84%E9%94%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png)
当一个线程创建后，处于新建状态，新建状态的线程调用start()方法后会变为就绪状态，就绪状态的线程如果获得cpu则进入运行状态，正常结束或者异常退出后会变成死亡状态；Java虚拟机会为每个对象维持两个池：等待池和锁定池，等待池用于存储执行了该对象.wait()的所有线程，锁定池用来存储所有等待获取该对象锁的线程，在运行状态下，如果线程调用了wait()方法，那么该线程会暂停并被放入该对象等待池中，状态变为等待阻塞状态(WAITING状态)，当其他线程执行了该对象.notify/notigyAll()时，等待池中的一个/所有(取决于执行的是notify还是notifyAll)线程会放到该对象锁定池中，来竞争该对象的锁(具体唤醒哪一个线程是任意的，并不是等待时间最长的线程)；在运行状态下，一个线程拥有了一个对象的锁，那么其他竞争锁失败的线程都会被暂停进入同步阻塞状态(BLOCKED状态)，并放入该对象的锁定池中，如果该对象的锁被释放，则锁定池中一个任意的线程会被唤醒并参竞争对象锁，如果成功获取到锁，那么该线程会变为就绪状态，否则继续处于同步阻塞状态，继续留在锁定池中；在运行状态下，如果一个线程调用了sleep()方法，那么该线程会进入阻塞状态(TIMED_WAITING状态)，当sleep结束后，该线程变为就绪状态。
在看完Java线程状态后，来介绍一下Java中的锁。从宏观上来说，锁分为两种：乐观锁和悲观锁：
- 乐观锁：乐观思想的锁，认为读多写少，在取数据时认为别人不会修改数据，所以不上锁，在更新数据的时候会加锁比对一下在此期间有没有人更改数据，如果比对出来数据有更新，则重复读-加锁比较-写的操作。
- 悲观锁：悲观思想的锁，认为写多，在每次取数据时都认为别人会修改数据，因此在每次读写数据时都会加锁。

Java中的乐观锁基本上都是通过CAS操作实现的。
在介绍Java中的各种锁之前，需要先看一下markword，markword是对象数据结构的一部分，它最后两位代表了对象所处的状态：
- 01：未锁定，当倒数第3位为1时代表可偏向状态，markword中存储了对象的哈希值、分代年龄和偏向线程ID
- 00：轻量锁定，markword中存储了指向栈帧中所记录的指针
- 10：重量级锁定，markword中存储了指向重量级锁的指针

接下来介绍一下Java中的各种锁：
#### 自旋锁
自旋锁在竞争失败后不会立刻挂起，而是先自旋（相当于等待，cpu在做无用功）一段时间，等到持有锁的线程释放锁后可以立即获取锁，这样避免了线程挂起时进行用户态和内核态的切换，减少了开销。但如果一直获取不到锁，cpu会一直在做无用功，所以需要设定一个最大等待时间，jdk1.7之后自旋的次数由JVM控制。
#### 偏向锁
偏向锁会偏向于第一个获取锁的线程，如果在运行过程中，同步锁只有一个线程访问，那么就会加一个偏向锁，如果遇到了竞争，那么持有偏向锁的线程会在安全点被挂起，偏向锁将升级为轻量级锁。偏向锁获取过程如下：
线程判断markword中偏向锁的标识是否是1，并且锁标志位是否是01，如果是，代表是可偏向状态，然后判断markword中的线程ID是否是当前线程，如果是，则代表线程持有偏向锁，执行同步代码；如果不是，则通过CAS操作将对象markword中的线程ID设置为当前线程，如果成功则代表线程获取了锁，执行同步代码，如果失败则表明存在竞争，当到达安全点时持有偏向锁的线程会被挂起，将对象markword中偏向标志置为0撤销偏向，偏向锁升级为轻量级锁。
#### 轻量级锁
轻量级锁是由偏向锁升级而来，加锁过程如下： 虚拟机在当前线程的栈帧中建立一个锁记录（Lock Record）的空间，将对象的markword拷贝到锁记录中，然后使用CAS操作将对象的markword替换为指向锁记录的指针，并将锁记录中的owner指针指向markword，如果更新成功代表该线程拥有了这个对象的锁，执行同步代码，如果更新失败，则线程进行自旋，自旋后如果成功获取锁，那么继续保持轻量级锁，如果自旋失败，那么轻量级锁就要膨胀成为重量级锁，markword中锁标志变为10。获取轻量级锁的线程执行完同步代码后，会使用CAS将锁记录中的markword拷贝替换回对象头中，如果成功代表没有竞争发生，如果失败则膨胀为重量级锁。轻量级锁是一种自旋锁，等待轻量级锁的线程不会直接阻塞，而是会进行自旋。
#### 重量级锁
重量级锁依赖于系统互斥量（mutex）实现，会阻塞线程，导致用户态和内核态的切换，开销较大。

jdk1.6之后synchronized使用了偏向锁和轻量级锁机制，依次由偏向锁、轻量级锁再到重量级锁。
参考内容：
https://blog.csdn.net/zqz_zqz/article/details/70233767?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

https://blog.csdn.net/u012722531/article/details/78244786

https://blog.csdn.net/qq_38835878/article/details/89375515