---
title: JVM内存模型以及GC机制
date: 2019-05-05 14:50:48
categories: Java
tags:
 - JVM
 - GC
---
#### JVM内存模型
Java虚拟机在运行Java程序的时候会把内存划分成几个不同的区域，包括以下几个运行时数据区域：  
![JVM内存模型](https://xiaobai-picture.oss-cn-beijing.aliyuncs.com/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8AGC%E6%9C%BA%E5%88%B6/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)  
<!-- more -->
 - 程序计数器：线程私有，是一块比较小的内存区域，是当前线程所执行的字节码的行号指示器。如果当前线程执行的是一个Java方法，那么它存的就是正在执行的字节码指令的地址；如果执行的是Native方法,那么它就是空。
 - 虚拟机栈：线程私有，描述Java方法执行的内存模型。每个方法在执行的时候JVM就会在栈中划分出一块内存，称为栈帧用于存储局部变量表（用于存储方法的参数以及方法内部定义的局部变量）、操作数栈（可以理解为虚拟机栈中一个用于计算的临时数据存储区域）、动态链接（指向方法区中该栈帧所属方法的引用）以及方法返回地址。
 - 本地方法栈：线程私有，与虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机用到的Native方法服务。
 - 堆：线程共享，是JVM所管理的内存中最大的一块，在虚拟机启动的时候创建，作用是存放对象实例，几乎所有对象都是在这里分配内存，也是垃圾收集器管理的主要区域。
 - 方法区：线程共享，用于存储已经被JVM加载的类信息、常量、静态变量等数据。
   
#### GC机制
在垃圾收集器对堆进行回收前，首先要确定哪些需要回收，也就是要确定哪些对象是存活的，最简单的一个方法就是引用计数法：
##### 引用计数法
给对象添加一个引用计数器，每当有一个地方引用它计数器就加一，当引用失效时计数器就减一，任何时刻计数器是0的就代表这个对象需要被回收。引用计数法实现简单，判定效率高，但是有一个致命的问题：它无法解决对象循环引用的问题，如果两个对象循环引用，那么它们的计数器永远不可能为0，因此商用的虚拟机并不是通过引用计数法来判断对象是否存活的，主流的商用虚拟机是通过可达性分析来判断对象的存活的。
##### 可达性分析法
这个算法的基本思想是通过将一系列对象作为初始点（GC Roots）,从这些初始点开始向下搜索对应的引用节点，找到后接着向下搜索...搜索所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链时（即GC Roots到这个对象不可达），则证明这个对象是不可用的，将被判定为可回收对象。在Java中，可以作为GC Roots的有以下几种：
 1. 虚拟机栈栈帧中本地变量表中引用的对象。
 2. 方法区中静态属性引用的对象。
 3. 方法区中常量引用的对象。
 4. 本地方法栈中引用的对象。
  
找到哪些对象需要回收后，就需要进行垃圾回收了，垃圾回收算法主要有以下几种：
##### 标记-清除算法
标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段：首先标记出所有需要回收的对象，标记完后回收所有被标记对象。标记的过程上面已经说过。它最主要的问题是标记和清除的效率都不高，而且回收后会产生大量不连续的内存碎片。它的执行过程如下图：  
![标记-清除](https://xiaobai-picture.oss-cn-beijing.aliyuncs.com/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8AGC%E6%9C%BA%E5%88%B6/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.png)
##### 复制算法
为了解决效率问题而出现的算法。复制算法将可用内存分为大小相等的两块，每次只适用其中一块，当着一块内存用完了，就将还存活的对象复制到另外一块，然后把已使用过的内存空间全部回收。复制算法的缺点是内存开销太大，有一半的内存空闲但不能使用。它的过程如下图：
![复制算法](https://xiaobai-picture.oss-cn-beijing.aliyuncs.com/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8AGC%E6%9C%BA%E5%88%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)
##### 标记-整理算法
当存活对象很多的时候，复制算法就需要进行较多的复制操作，效率会变低，而且会浪费50%的空间，因此就有了标记-整理算法。标记过程与标记-清除算法相同，但是后续不是直接将可回收对象回收，而是将所有存活对象都移向一端，然后直接清理掉边界以外的内存，过程如下图：
![标记-整理](https://xiaobai-picture.oss-cn-beijing.aliyuncs.com/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8AGC%E6%9C%BA%E5%88%B6/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.png)  
##### 分代收集算法
大部分商用虚拟机都是采用的分代收集算法，根据对象的存活周期把内存划分为几代，一般是把堆分为新生代和老年代。新生代中每次GC时都有大批对象被收集，只有少量存活，因此选用复制算法，将新生代分为一块较大的Eden区和两块较小的Survivor区(HotSpot虚拟机默认Eden区和Survivor区的大小是8:1)，每次使用Eden区和其中一块Survivor区，对象创建是默认都在Eden区分配内存（一些大对象会直接在老年代分配，可以通过jvm参数-XX:PretenureSizeThreshold设置阀值，超过这个阀值的对象会直接在老年代分配内存），当Eden区满时，会触发新生代GC（Minor GC）,将Eden区和Survivor区中存活的对象复制到另一块Survivor区中，然后回收Eden区和刚才用过的Survivor区，对象每经历一次Minor GC则“年龄”增长一岁，当年龄到达阀值（可以通过jvm参数-XX:MaxTenuringThreshold设置阀值）时，在Minor GC时会被转移到老年代。如果在Minor GC时Survivor区不够用时，则将对象放到老年代中。老年代中一般采用标记-整理或者标记-清除算法进行垃圾回收，老年代控件不足时会触发Full GC，对整个堆进行清理。